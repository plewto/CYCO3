<!DOCTYPE HTML>
<html lang="en">

  <head>
      <meta charset="UTF-8">
      <meta name="robots" content="index,follow,archive">
      <meta name="keywords" content="NIL">
      <link rel="stylesheet" type="text/css" href="style.css"/>
      <title>CYCO Patterns</title>
      <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'/>
      <link href='https://fonts.googleapis.com/css?family=PT+Serif' rel='stylesheet' type='text/css'/>
      <link href='https://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'/>
  </head>
  
<body lang="en-US">
  <a id="top"></a>
  <a href=index.html class="link">Home</a> &nbsp;<a href=channel-names.html class="navigation">Previous: channel-names </a> &nbsp;<a href=nodes.html class="navigation">Next: nodes </a> &nbsp;<a href=contents.html class="navigation">Contents </a> &nbsp;
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <img class="center" src="images/patterns.png" alt="patterns"/>
  <h1 class="banner">CYCO Patterns</h1>
  <p class="body">
    A <strong>PATTERN</strong> is a generator which returns a sequence of values in some
    prescribed manner.  The two most
    basic pattern types are the <i>cycle</i> and <i>line</i>.
  </p>
  <p class="body">
    A <strong>CYCLE</strong> returns elements in a cyclical manner.
  </p>
  <pre class="code">
    (CYCLE :of '(A B C)) --> A B C A B C A B C A...
  </pre>
  <p class="body">
    A <strong>LINE</strong> returns elements in sequence.  Once all elements have been
    returned it continues to return the final element.
  </p>
  <pre class="code">
    (LINE :of '(A B C)) --> A B C C C C C...
  </pre>
  <a id="functions"></a>
  <H2 class="heading">Functions on Patterns</H2>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="next-1"></a>
  
  <!-- (NEXT-1 pattern) -->
  <!--  -->
  <!--  -->
  <b class="definition">(NEXT-1 pattern)</b><br>
  <p class="summery">Returns the next value from pattern.</p>
  <pre class="description">
    NEXT-1 is called recursively on nested patterns.
    	
    	(param foo (cycle :of '(A B C)))
    	(next-1 foo) --> A
    	(next-1 foo) --> B
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="next-n"></a>
  
  <!-- (NEXT-N pattern n) -->
  <!--  -->
  <!--  -->
  <b class="definition">(NEXT-N pattern n)</b><br>
  <p class="summery">Returns list of next n pattern values.</p>
  <pre class="description">
    (param foo (cycle :of '(A B C D)))
     (next-1 foo)   --> A
     (next-n foo 2) --> (B C)
     (next-1 foo)   --> D
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="next"></a>
  
  <!-- (NEXT pattern &optional n) -->
  <!--  -->
  <!--  -->
  <b class="definition">(NEXT pattern &optional n)</b><br>
  <p class="summery">Returns next value from pattern.</p>
  <pre class="description">
    By default NEXT acts exactly like NEXT-1.  If the optional n argument is an integer
    it behaves like (NEXT-n pattern n) and returns a list of n values.
    
    If n is the keyword :ALL then a list of all elements are returned.
    If n is the keyword :REST then a list of all remaining elements is returned.
    
        (param foo (cycle :of '(A B C D E F G H)))
        (next foo)       --> A
        (next foo)       --> B
        (next foo 3)     --> (C D E)
        (next foo :rest) --> (F G H)
        (next foo :all)  --> (A B C D E F G H)
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="value"></a>
  
  <!-- (VALUE pattern) -->
  <!--  -->
  <!--  -->
  <b class="definition">(VALUE pattern)</b><br>
  <p class="summery">Returns current value of pattern.</p>
  <pre class="description">
    (param foo (cycle :of '(A B C)))
    (next foo)  --> A
    (value foo) --> A
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="reset"></a>
  
  <!-- (RESET pattern) -->
  <!--  -->
  <!--  -->
  <b class="definition">(RESET pattern)</b><br>
  <p class="summery">Resets pattern to initial state.</p>
  <pre class="description">
    (param foo (cycle :of '(A B C D E F)))
    (next foo)   --> A
    (next foo)   --> B
    (reset foo)
    (next foo)   --> A
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="pattern-p"></a>
  
  <!-- (PATTERN-P object) -->
  <!--  -->
  <!--  -->
  <b class="definition">(PATTERN-P object)</b><br>
  <p class="summery">Predicate, true if object is a pattern type.</p>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="cardinality"></a>
  
  <!-- (CARDINALITY pattern) -->
  <!--  -->
  <!--  -->
  <b class="definition">(CARDINALITY pattern)</b><br>
  <p class="summery">Returns number of elements in pattern.</p>
  <pre class="description">
    Cardinality is not well defined for all pattern types.   For such
    cases the result is somewhat arbitrary or user specified.
    
    (param foo (cycle :of '(A B C)))
    (cardinality foo) --> 3
    
    Cardinality is not 'naturally' defined for the coin pattern.
    Use the :period keyword to set an arbitrary cardinality.
    
    (param baz (coin :period 8))
    (cardinality baz) --> 8
    (next baz :rest)  --> (T NIL NIL T T NIL T)
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="remaining"></a>
  
  <!-- (REMAINING pattern) -->
  <!--  -->
  <!--  -->
  <b class="definition">(REMAINING pattern)</b><br>
  <p class="summery">Returns number of remaining elements.</p>
  <pre class="description">
    Remaining is not well defined for all pattern types.
    
    (param foo (cycle :of '(A B C D E F G)))
    (next foo 3)    --> (A B C)
    (remaining foo) --> 4
    
    (param baz (coin :period 8))
    (next baz 2)    --> (nil nil)
    (remaining baz) --> 6
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="to-pattern"></a>
  
  <!-- (->PATTERN object &key pattern-type) -->
  <!--  -->
  <!--  -->
  <b class="definition">(->PATTERN object &key pattern-type)</b><br>
  <p class="summery">Coerce object to pattern.</p>
  <pre class="description">
    If (PATTERN-P object) is true return object.
    Otherwise return pattern of type pattern-type (default cycle) with object as
    its elements.  
    
    (param foo '(A B C))
    (param baz (->pattern foo))
    (cycle-p baz) --> t
    
    (param bez (->pattern foo :pattern-type 'line))
    (next bez 6)  --> (A B C C C C)
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="transpose"></a>
  
  <!-- (TRANSPOSE pattern n) -->
  <!--  -->
  <!--  -->
  <b class="definition">(TRANSPOSE pattern n)</b><br>
  <p class="summery">Apply key transposition to pattern elements.</p>
  <pre class="description">
    (param foo (cycle :of '(60 61 62)))
    (transpose foo 4)
    (next foo :all) --> (64 65 66)
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="invert"></a>
  
  <!-- (INVERT pattern pivot) -->
  <!--  -->
  <!--  -->
  <b class="definition">(INVERT pattern pivot)</b><br>
  <p class="summery">Apply key inversion to pattern elements.</p>
  <pre class="description">
    (param foo (cycle :of '(60 61 62)))
    (invert foo 61)
    (next foo :all) --> (62 61 59)
    
    The pivot argument may be a symbolic key-number.
    (invert foo 'c6)
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="retrograde"></a>
  
  <!-- (RETROGRADE pattern) -->
  <!--  -->
  <!--  -->
  <b class="definition">(RETROGRADE pattern)</b><br>
  <p class="summery">Reverse order of pattern elements.</p>
  <pre class="description">
    (param foo (cycle :of '(A B C)))
    (retrograde foo)
    (next foo :all) --> (C B A)
    
    Retrograde is not defined for all pattern types.  Where
    undefined the pattern is unaltered.
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="clone"></a>
  
  <!-- (CLONE pattern) -->
  <!--  -->
  <!--  -->
  <b class="definition">(CLONE pattern)</b><br>
  <p class="summery">Returns deep copy of pattern</p>
  <p class="body">
    <br>
  </p>
  <H2 class="heading">Pattern Types</H2>
  <a id="line"></a>
  
  <!-- (LINE &key of) -->
  <!--  -->
  <!--  -->
  <b class="definition">(LINE &key of)</b><br>
  <p class="summery">Creates new LINE pattern.</p>
  <pre class="description">
    A LINE returns its elements in sequence until the final element is reached, 
    thereafter it returns the final value indefinitely.
    
     (param foo (line :of '(A B C)))
     (next foo 8) --> A B C C C C C C...
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="cycle"></a>
  
  <!-- (CYCLE &key of) -->
  <!--  -->
  <!--  -->
  <b class="definition">(CYCLE &key of)</b><br>
  <p class="summery">Creates new CYCLE pattern.</p>
  <pre class="description">
    A CYCLE returns its elements in sequence.  Once the final element has been 
     reached the cycle repeats.
    
     (param foo (cycle :of '(A B C)))
     (next foo 8) --> A B C A B C A B...
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="bag"></a>
  
  <!-- (BAG &key of final) -->
  <!--  -->
  <!--  -->
  <b class="definition">(BAG &key of final)</b><br>
  <p class="summery">Creates new BAG pattern.</p>
  <pre class="description">
    A BAG returns its elements at random without replacement, once all elements have been 
    returned a bag returns the final element indefinitely. 
    
    (param foo (bag :of '(A B C) :final 'end)))
    (next foo 8) --> B A C END END END END END
    
    The final element my itself be a pattern.
    
    (param foo (bag :of '(A B C) :final (cycle :of '(ape bat)))
    (next foo 8) --> C A B APE BAT APE BAT APE
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="dice"></a>
  
  <!-- (DICE &key of) -->
  <!--  -->
  <!--  -->
  <b class="definition">(DICE &key of)</b><br>
  <p class="summery">Creates new DICE pattern.</p>
  <pre class="description">
    A DICE returns its elements randomly with replacement.
    
    (param foo (dice :of '(A B C)))
    (next foo 8) --> B C B A C C A B
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="coin"></a>
  
  <!-- (COIN &key (p 0.5)(head #'true)(tail #'false)(period nil)) -->
  <!--  -->
  <!--  -->
  <b class="definition">(COIN &key (p 0.5)(head #'true)(tail #'false)(period nil))</b><br>
  <p class="summery">Creates new COIN pattern.</p>
  <pre class="description">
    A COIN is like a two-sided dice but with the ability to call functions.
        
    :P      - Probability of 'head' result.  0 &lt;= p &lt;= 1, default 0.5.
    :HEAD   - The 'head' value, default #'TRUE.
    :TAIL   - The 'tail' value, default #'FALSE.
    :PERIOD - Sets an arbitrary cardinality.
    
    The head and tail parameters may be any of the following types:
    
      - literal value.
      - pattern, apply NEXT-1 when selected.
      - function, call when selected.
    
    The default behavior returns nil or t with equal probability.
    
    (param foo (coin))
    (next foo 10) --> T T NIL T T NIL NIL NIL T NIL
    
    The RETROGRADE method swaps head/tail probability.
        
    (param foo (coin :p 0.75)) ;; head probability 75%
    (retrograde foo)           ;; head probability now 25%
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="wrapper"></a>
  
  <!-- (WRAPPER &key (of #'identity)(period 16)) -->
  <!--  -->
  <!--  -->
  <b class="definition">(WRAPPER &key (of #'identity)(period 16))</b><br>
  <p class="summery">Creates new WRAPPER pattern.</p>
  <pre class="description">
    A WRAPPER allows a function to be treated as a pattern.  The function should
    take a single integer argument and has no prescribed return type.  With each 
    call to NEXT-1 the function is called with an increasing integer argument.
    Once period values have been produced the count begins over at 0.
    
    Using wrapper to simulate a cycle.
    
    (param foo (wrapper :of #'(lambda (n)(* n 2)) :period 4))
    (next foo 10) --> 0 2 4 6 0 2 4 6 0 2 
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a id="walker"></a>
  
  <!-- (WALKER &key of) -->
  <!--  -->
  <!--  -->
  <b class="definition">(WALKER &key of)</b><br>
  <p class="summery">Creates new WALKER pattern.</p>
  <pre class="description">
    A WALKER produces a random walk over its elements.
    
    (param foo (walker :of '(A B C D)))
    (next foo 8) --> D C B A B C B A
  </pre>
  <p class="body">
    <br>
  </p>
  <a id="nested-patterns"></a>
  <H2 class="heading">Nested Patterns</H2>
  <p class="body">
    The NEXT-1 method is applied recursively to nested patterns.  This means that most patterns may 
    be nested to any depth.
  </p>
  <pre class="code">
    
        ;; A LINE with nested CYCLE.
        ;;
        (param foo (line :of (list 'A 'B 'C (cycle :of '(1 2 3)))))
        (next foo 10) --> A B C 1 2 3 1 2 3 1...  
        
        ;; A CYCLE with nested LINE.
        ;;
        (param foo (cycle :of (list 'A 'B (line :of '(1 2 3)))))
        (next foo 15) --> A B 1 A B 2 A B 3 A B 3 A B 3...
    
        ;; A DICE of CYCLE and LINE.
        ;;
        (param foo (dice :of (list (cycle :of '(A B C))(line :of '(1 2 3)))))
        (next foo 16) --> 1 2 A 3 B C 3 A 3 B C 3 A B 3...
  </pre>
  <H2 class="heading">Pseudo Patterns</H2>
  <p class="body">
    The following special case patterns have numeric values only.
    They may not contain nested patterns.
  </p>
  <a id="ramp"></a>
  
  <!-- (RAMP start end &key steps) -->
  <!--  -->
  <!--  -->
  <b class="definition">(RAMP start end &key steps)</b><br>
  <pre class="description">
    Special case LINE pattern, produces linear sequence from start to end values 
    
    start  - Initial value.
    end    - Final value.  The final value is never reached.
    :steps - Number of steps, default 16.
    
    Returns LINE pattern.
    
        (param foo (ramp 0 8 :steps 8))
        (next foo :all) --> (0 1.0 2.0 3.0 4.0 5.0 6.0 7.0)
  </pre>
  <a id="sawtooth"></a>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  
  <!-- (SAWTOOTH amp1 amp2 &key cycles steps phase) -->
  <!--  -->
  <!--  -->
  <b class="definition">(SAWTOOTH amp1 amp2 &key cycles steps phase)</b><br>
  <pre class="description">
    Special case CYCLE for producing numeric sawtooth pattern.
    
    amp1    - Minimum value.
    amp2    - Maximum value.  The maximum value is never reached.
    :cycles - Int, number of sawtooth cycles, default 1.
    :steps  - Int, number of points, default 16.
    :phase  - Int, phase shift in degrees, default 0.
    
    Returns CYCLE pattern.
    
        (param foo (sawtooth 0 10 :steps 10 :phase 0))
        (next foo :all) --> (0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0)
  </pre>
  <a id="triangle"></a>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  
  <!-- (TRIANGLE amp1 amp2 &key cycles steps phase) -->
  <!--  -->
  <!--  -->
  <b class="definition">(TRIANGLE amp1 amp2 &key cycles steps phase)</b><br>
  <pre class="description">
    Special case CYCLE for producing numeric triangle pattern.
    
    amp1    - Minimum value.
    amp2    - Maximum value.
    :cycles - Int, number of triangle cycles, default 1.
    :steps  - Int, number of points, default 16.
    :phase  - Int, phase shift in degrees, default 0.
    
    Returns CYCLE pattern.
    
        (param foo (triangle 0 10 :steps 10 :phase 0))
        (next foo :All) --> (0 2.0 4.0 6.0 8.0 10 8.0 6.0 4.0 2.0)
  </pre>
  <a id="pulse"></a>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  
  <!-- (PULSE amp1 amp2 &key cycles  width steps phase) -->
  <!--  -->
  <!--  -->
  <b class="definition">(PULSE amp1 amp2 &key cycles  width steps phase)</b><br>
  <pre class="description">
    Special case CYCLE for producing numeric pulse pattern.
    
    amp1    - Minimum value.
    amp2    - Maximum value.
    :cycles - Int, number of pulse cycles, default 1.
    :width  - Float, pulse width 0.0 &lt;&equals; width &lt;&equals; 1.0, default 0.5
    :steps  - Int, number of points, default 16.
    :phase  - Int, phase shift in degrees, default 0.
    
    Returns CYCLE pattern.
    
        (param foo (pulse 0 1))
        (next foo :all) -> (0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1)
    
        (param foo (pulse 0 1 :width 0.8))
        (next foo :all) -> (0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1)
    
        (param foo (pulse 0 1 :width 0.8 :phase 90))
        (next foo :all) -> (0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0)
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <H4 class="heading">Integer patterns</H4>
  <p class="body">
    <b>IRAMP, ISAWTOOTH, ITRIANGLE</b> and <b>IPULSE</b> are
    integer versions of the patterns above.   They each take the same arguments
    as the corresponding patterns.  Unlike the non-integer versions they all
    guarantee the ending value will appear in the result.   However the resulting
    sequence may have uneven step-sizes and my not be strictly monotonic.
  </p>
  <pre class="code">
    
    
        ;; ramp produces consistent step sizes but ending value is missing.
        ;;
        (next (ramp  0 9 :steps 10) :all) --&gt; (0 0.9 1.8 2.7 3.6 4.5 5.4 6.3 7.2 8.1)
    
        ;; iramp produces ending value but steps size may be inconsistent and 
        ;; some values may be repeated.
        ;;
        (next (iramp 0 9 :steps 10) :all) --&gt; (0 1 2 3 4 5 6 7 8 9)
        (next (iramp 0 9 :steps 12) :all) --&gt; (0 1 2 2 3 4 5 6 7 7 8 9)
        (next (iramp 0 9 :steps  5) :all) --&gt; (0 2 4 7 9)
  </pre>
  <hr style='height:4px;border-width:0;color:green;background-color:gray'/>
  <a href=index.html class="link">Home</a> &nbsp;<a href=channel-names.html class="navigation">Previous: channel-names </a> &nbsp;<a href=nodes.html class="navigation">Next: nodes </a> &nbsp;<a href=#top class="navigation">Top </a> &nbsp;<a href=contents.html class="navigation">Contents </a> &nbsp;
  
</body>
</html>