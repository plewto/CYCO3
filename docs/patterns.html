<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="index,follow,archive">
    <meta name="description" content="CYCO Documentation">
    <link rel="stylesheet" type="text/css" href="style.css"/>
    <link rel="icon" href="icon.png"/>
    <title>CYCO Patterns</title>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=PT+Serif' rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'/>
    
</head>

<body>
<div id="page_wrapper">
<a class="navigation" href="home.html">Home</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="navigation" href="contents.html">Contents</a>
&nbsp;&nbsp;&nbsp;&nbsp;<b class="navigation">Previous:</b>&nbsp;<a class="navigation" href="plugins.html">Plugins</a>
&nbsp;&nbsp;&nbsp;&nbsp;<b class="navigation">Next:</b>&nbsp;<a class="navigation" href="markov-chains.html">Markov-Chains</a>

<h2 class="section-head">Patterns</h2>
<hr/>
<p class="body">
    A <em>Pattern</em> is an object which returns a sequence of values in    some prescribed manner.  To thicken the plot patterns may be nested    to any depth.  Whenever a pattern is an element of another pattern,  the    nested pattern returns it's values,  which of course could be still more    patterns.</p>
<p class="body">
    Quick Links:</p>
<ul>
    <li><a href='#pattern-functions'>Functions on patterns</a></li>
    <li><a href='#line'>Line pattern</a></li>
    <li><a href='#cycle'>Cycle pattern</a></li>
    <li><a href='#bag'>Bag pattern</a></li>
    <li><a href='#dice'>Dice pattern</a></li>
    <li><a href='#coin'>Coin pattern</a></li>
    <li><a href='#wrapper'>Function Wrapper</a></li>
    <li><a href='#walker'>Random Walks</a></li>
    <li><a href='#markov.html'>Markov Chains</a></li>
    <li><a href='#shift-register.html'>Shift Register</a></li>
    <li><a href='#slew'>Pattern Slew</a></li>
    <li><a href='#nested'>Nested Patterns</a></li>
</ul>
<a id="pattern-functions"></a>
<hr/>
<h4 class="section-head">Pattern Functions</h4>
<b class="definition">(NEXT-1 pattern)</b><br>
<p class="synopsis">Returns next value from pattern.</p>
<b class="definition">(NEXT-N pattern n)</b><br>
<p class="synopsis">Returns list of next n pattern values.</p>
<b class="definition">(NEXT pattern &optional n)</b><br>
<p class="synopsis">By default returns next value from pattern (as per NEXT-1).<br>
If n is a positive integer, returns list of next n values (as per NEXT-N).<br>
If n is the keyword :ALL, returns list of all elements from the pattern.<br>
If n is the keyword :REST, returns list of all values yet to be returned.</p>
<p class="synopsis">The behavior of the :ALL and :REST options is not consistent across all
pattern types.   For instance with a Markov Chain, ALL and REST do not have 
obvious meanings. In such cases the results are somewhat arbitrary.</p>
<b class="definition">(VALUE pattern)</b><br>
<p class="synopsis">Returns the current value of pattern.</p>
<b class="definition">(RESET pattern)</b><br>
<p class="synopsis">Restore pattern, and all nested patterns, to their initial state.</p>
<b class="definition">(PATTERN-P object)</b><br>
<p class="synopsis">Predicate, true if object is a Pattern.</p>
<b class="definition">(CARDINALITY pattern)</b><br>
<p class="synopsis">Returns the number of elements in the pattern.<br>
Cardinality is not well defined for all pattern types.</p>
<b class="definition">(REMAINING pattern)</b><br>
<p class="synopsis">Returns count of elements yet to be returned.<br>
Remaining is not well defined for all pattern types.</p>
<b class="definition">(-&gt;PATTERN object &key ptype)</b><br>
<p class="synopsis">Coerce object to a Pattern.<br>
If (PATTERN-P object) is true, return object.<br>
Otherwise return pattern of type ptype with object as an element.&nbsp;
ptype defaults to CYCLE.</p>
<b class="definition">(TRANSPOSE pattern n)</b><br>
<p class="synopsis">Apply key transposition to pattern elements.<br>
Transpose is not defined for all pattern types, where undefined 
returns the pattern unaltered.</p>
<b class="definition">(INVERT pattern pivot)</b><br>
<p class="synopsis">Apply key inversion on pattern elements.<br>
Invert is not defined for all pattern types, where undefined
returns pattern unaltered.</p>
<b class="definition">(RETROGRADE pattern)</b><br>
<p class="synopsis">Reverse order of pattern elements.<br>
Retrograde is not defined for all pattern types, where undefined
returns pattern unaltered.</p>
<b class="definition">(clone pattern)</b><br>
<p class="synopsis">Returns a deep copy of pattern.  The original and the 
clone will have no objects in common.</p>
<a id="line"></a>
<hr/>
<b class="definition">(LINE &key of)</b><br>
<p class="synopsis">A <em>Line</em> is a simple pattern which returns values in
sequence until the final value is reached.  Thereafter it continues to
return the final value indefinitely.</p>
<pre class="code">
(param foo (line :of '(A B C)))

(next foo)  --> A
(next foo)  --> B
(next foo)  --> C
(next foo)  --> C
(next foo)  --> C
</pre>
<a id="cycle"></a>
<hr/>
<b class="definition">(CYCLE &key of)</b><br>
<p class="synopsis">A <em>Cycle</em> is a pattern which returns elements in a cyclical
manner.</p>
<pre class="code">
(param cyc (cycle :of '(A B C)))

(next cyc) --> A
(next cyc) --> B
(next cyc) --> C
(next cyc) --> A
(next-n cyc 2) --> (B C)
(next-n cyc 2) --> (A B)
</pre>
<a id="bag"></a>
<hr/>
<b class="definition">(BAG &key of final)</b><br>
<p class="synopsis">A <em>Bag</em>&nbsp;&nbsp;returns elements randomly without replacement.  Once
all elements have been returned, indefinitely returns a designated
final element.   The final element may itself be a Pattern.</p>
<pre class="code">
(param bg (bag :of '(A B C) :final 1234))

(next bg) --> B
(next bg) --> A
(next bg) --> C
(next bg) --> 1234
(next bg) --> 1234

The final argument may be another pattern.

(setf bg (bag :of '(A B C) :final (line :of '(1 2 3))))
 	   
(next bg) --> B
(next bg) --> A
(next bg) --> C
(next bg) --> 1
(next bg) --> 2
(next bg) --> 3
(next bg) --> 3
</pre>
<a id="dice"></a>
<hr/>
<b class="definition">(DICE &key of)</b><br>
<p class="synopsis">A <em>Dice</em> returns elements at random with replacement.</p>
<pre class="code">
(param dc (dice :of '(A B C)))

(next dc) --> B
(next dc) --> A
(next dc) --> A
(next dc) --> C
(next dc) --> B
</pre>
<a id="coin"></a>
<hr/>
<h4 class="section-head">Coin Pattern</h4>
<p class="body">
    A <em>Coin</em> is like a two-sided dice but with the ability to call    functions.</p>
<pre class="code">
(coin :p n :head value :tail value :period n)

:p n - sets probability of getting a 'head', default 0.5
:head - the 'heads' value, default #'true
:tail - the 'tails' value, default #'false
:period n - sets an arbitrary cardinality.
</pre>
<p class="body">
    The head and tail arguments may be any of the following:</p>
<ul>
    <li>literal value</li>
    <li>pattern</li>
    <li>function to be called when selected</li>
</ul>
<p class="body">
    The default behavior is to return nil or t with equal probability.</p>
<pre class="code">
(next-n (coin) 10) --> (T T NIL T T NIL NIL NIL NIL NIL)
</pre>
<p class="body">
    The RETROGRADE method swaps head/tail probability.</p>
<pre class="code">
(param foo (coin :p 0.75))     ;; create coin with head probability of 75%.
(retrograde foo)               ;; head probability now 25%.
</pre>
<a id="wrapper"></a>
<hr/>
<b class="definition">(WRAPPER &key (of #'identity)(period 16))</b><br>
<p class="synopsis">A <em>Wrapper</em> allows a function to be treated as a Pattern.  The function 
should take a single argument and return whatever it will.  Each call to next-1
calls the function with an ever increasing integer value.</p>
<pre class="code">
(wrapper &key (of #'identity)(period 16))

:of - The wrapped function, default (lambda n) --> n
:period - upper limit to the internal counter.


(param foo (wrapper :period 8))
(next foo 16) --> (0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7)

(let ((current 0))
   (param baz (wrapper :of #'(lambda (q)
                                (prog1 
                                    current
                                  (setf current (+ current q))))
                       :period 8))) 
(next baz 16) --> (0 0 1 3 6 10 15 21 28 28 29 31 34 38 43 49)
</pre>
<a id="walker"></a>
<hr/>
<b class="definition">(WALKER &key of)</b><br>
<p class="synopsis">A <em>Walker</em> is a pattern that random walks over it's elements. Nested patterns 
are called recursively.</p>
<pre class="code">
(walker &key of)

(param foo (walker :of '(A B C D)))
(next foo 8) --> (D C B A B C B A)


(param cyc (cycle :of '(APE BAT CAT)))
(param baz (walker :of (list 1 2 3 cyc)))
(next baz 9) --> (APE 1 BAT 3 2 1 2 3 CAT)
</pre>
<a id="slew"></a>
<hr/>
<b class="definition">(SLEW pattern delay)</b><br>
<p class="synopsis">A <em>Slew</em> is a modifier which extends the length of another pattern.</p>
<pre class="code">
(slew pattern delay)

(param foo (slew (cycle :of '(A B C)) 3))
(next foo 12) --> (A A A B B B C C C A A A)	   


;; The client pattern may exist outside of the slew.
;;
(param cyc (cycle :of '(A B C D E F)))
(param baz (slew cyc 3))
(next baz 6) --> (A A A B B B)
(next cyc 3) --> (C D E)
(next baz 6) --> (F F F A A A)
</pre>
<a id="nested"></a>
<hr/>
<h4 class="section-head">Nested Patterns</h4>
<p class="body">
    Patterns may be nested to any depth.</p>
<pre class="code">

;; Cycle contained in a line.
;;
(param foo (line :of (list 'A 'B 'C (cycle :of '(1 2 3)))))
(next-n foo 10) --> (A B C 1 2 3 1 2 3 1)

;; Line contained in cycle.
;;
(param foo (cycle :of (list 'A 'B (line :of '(1 2 3)))))
(next-n foo 15) --> (A B 1 A B 2 A B 3 A B 3 A B 3)
	    
;; A dice of cycle and line
;;
(param foo (dice :of (list (cycle :of '(A B C))(line :of '(1 2 3)))))
(next-n foo 16) --> (1 2 A 3 B C 3 A 3 B 3 C 3 A B 3)
</pre>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#top">Top</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="navigation" href="home.html">Home</a>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="navigation" href="contents.html">Contents</a>
&nbsp;&nbsp;&nbsp;&nbsp;<b class="navigation">Previous:</b>&nbsp;<a class="navigation" href="plugins.html">Plugins</a>
&nbsp;&nbsp;&nbsp;&nbsp;<b class="navigation">Next:</b>&nbsp;<a class="navigation" href="markov-chains.html">Markov-Chains</a>

</div>
</body>
</html>
