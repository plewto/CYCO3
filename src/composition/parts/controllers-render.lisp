;;;; CYCO
;;;;
;;;; Defines methods to render controllers sub-part



(labels (;; Generates single bend event for each channel-index.
	 (create-bend-point
	  (time channel-index-list value blur)
	  (let* ((value~ (approximate value :scale blur :min -1 :max +1))
		 (data (bend->midi-data value~))
		 (lsb (aref data 0))
		 (msb (aref data 1))
		 (bend-events '()))
	    (dolist (channel-index channel-index-list)
	      (push (cons time (midi-pitch-bend channel-index lsb msb)) bend-events))
	    bend-events))

	 ;; Generates MIDI controller event for each channel-index.
	 (create-controller-point
	  (time channel-index-list controller-number value blur)
	  (let* ((value~ (approximate value :scale blur :min 0 :max +1))
		 (data (norm->midi-data value~))
		 (controller-events '()))
	    (dolist (channel-index channel-index-list)
	      (push (cons time (midi-control-change channel-index controller-number data)) controller-events))
	    controller-events))

	 ;; Generates MIDI channel pressure event for each channel index.
	 (create-pressure-point
	  (time channel-index-list value blur)
	  (let* ((value~ (approximate value :scale blur :min 0 :max +1))
		 (data (norm->midi-data value~))
		 (pressure-events '()))
	    (dolist (channel-index channel-index-list)
	      (push (cons time (midi-channel-pressure channel-index data)) pressure-events))
	    pressure-events))

	 ;; For each channel-index, generates a single MIDI controller,
	 ;; channel-pressure or bend event at time2.
	 ;; Returns nested list. 
	 (create-point
	  (time channel-index-list event-type value blur)
	  (cond ((and (numberp event-type) (<= 0 event-type) (< event-type 128))
	 	 (create-controller-point time channel-index-list event-type value blur))
	 	((eq event-type 'touch)
	 	 (create-pressure-point time channel-index-list value blur))
	 	((eq event-type 'bend)
		 (create-bend-point time channel-index-list value blur))
		(t (cyco-warning
		    (sformat "Invalid CONTROLLERS event-type ~A" event-type))
		   nil))) 

	 (create-line
	  (state offset channel-index-list)
	  (let* ((time1 (float (+ offset (controllers-state-time1 state))))
		 (time2 (+ offset (controllers-state-time2 state)))
		 (steps (controllers-state-steps state))
		 (time-increment (/ (abs (- time2 time1)) (1- steps)))
		 (value1 (float (controllers-state-value1 state)))
		 (value2 (controllers-state-value2 state))
		 (value-increment (/ (- value2 value1) (1- steps)))
		 (degree (controllers-state-cycles state))
		 (time time1)
		 (value value1)
		 (midi-events '()))
	    (dotimes (i steps)
	      (setf midi-events (append (create-point time channel-index-list
					      (controllers-state-event-type state)
					      (expt value degree)
					      (controllers-state-blur state))
				midi-events))
	      (setf time (+ time time-increment))
	      (setf value (+ value value-increment)))
	    midi-events))

	 ;; Creates sawtooth "scanner" wave with peaks at y1, y2.
	 ;; Slope is positive for y1<y2, and negative for y2<y1.
	 ;; Times, step and cycle count derived from state.
	 ;; Returns nested list  ((time . value)(time . value) ...)
	 ;; 
	 (scanner
	  (state offset y1 y2)	
	  (let* ((time1 (float (+ offset (controllers-state-time1 state))))
	 	 (time2 (+ offset (controllers-state-time2 state)))
	 	 (cycles (max 0 (controllers-state-cycles state)))
	 	 (steps (/ (controllers-state-steps state) cycles))
	 	 (time-increment (/ (abs (- time2 time1)) (1- steps)))
	 	 (value-increment (/ (- y2 y1) (1- steps)))
	 	 (time time1)
	 	 (value y1)
	 	 (result-list '()))
	    (dotimes (i (controllers-state-steps state))
	      (push (cons time value) result-list)
	      (setf time (+ time time-increment))
	      (setf value (+ value value-increment))
	      (if (< y1 y2)
		  (if (> value y2)(setf value y1))
		(if (< value y2)(setf value y1))))
	    (reverse result-list)))

	 (create-sawtooth
	  (state offset channel-index-list)
	  (let* ((y1 (controllers-state-value1 state))
		 (y2 (controllers-state-value2 state))
		 (points (scanner state offset y1 y2))
		 (event-type (controllers-state-event-type state))
		 (blur (controllers-state-blur state))
		 (midi-events '()))
	    (dolist (p points)
	      (setf midi-events (append midi-events
					(create-point (car p) channel-index-list event-type (cdr p) blur))))
	    midi-events))

	 (create-triangle
	  (state offset channel-index-list)
	  (let* ((y1 (controllers-state-value1 state))
		 (y2 (controllers-state-value2 state))
		 (saw (scanner state offset -1 1))
		 (points (let* ((a (float (- y1 y2))) ; wave-shape scanner sawtooth
				(b (- y1 (/ a 2)))    ; to triangle.
				(tri '()))
			   (dolist (p saw)
			     (let* ((time (car p))
				    (s (- (abs (cdr p)) 1/2))
				    (v (+ (* a s) b)))
			       (push (cons time v) tri)))
			   tri))
		 (event-type (controllers-state-event-type state))
		 (blur (controllers-state-blur state))
		 (midi-events '()))
	    (dolist (p points)
	      (setf midi-events (append midi-events (create-point (car p) channel-index-list event-type (cdr p) blur))))
	    midi-events))

	 (create-random-values
	  (state offset channel-index-list)
	  (let* ((time1 (float (+ offset (controllers-state-time1 state))))
		 (time2 (+ offset (controllers-state-time2 state)))
		 (steps (controllers-state-steps state))
		 (time-increment (/ (abs (- time2 time1)) (1- steps)))
		 (v1 (controllers-state-value1 state))
		 (v2 (controllers-state-value2 state))
		 (diff (float (abs (- v2 v1))))
		 (floor (min v1 v2))
		 (event-type (controllers-state-event-type state))
		 (time time1)
		 (midi-events '()))
	    (dotimes (i steps)
	      (let ((value (+ floor (random diff))))
		(setf midi-events (append midi-events (create-point time channel-index-list event-type value 0.0)))
		(setf time (+ time time-increment))))
	    midi-events))
	    
	 (create-sin1
	  (state offset channel-index-list)
	  (let* ((v1 (controllers-state-value1 state))
		 (v2 (controllers-state-value2 state))
		 (saw (scanner state offset 0 (* 2 pi)))
		 (a (/ (- v2 v1) 2.0))
		 (b (+ v1 a))
		 (event-type (controllers-state-event-type state))
		 (blur (controllers-state-blur state))
		 (midi-events '()))
	    (dolist (p saw)
	      (let ((s (+ (* (sin (cdr p)) a) b)))
		(setf midi-events (append midi-events (create-point (car p) channel-index-list event-type s blur)))))
	    midi-events))

	 (create-cos1
	  (state offset channel-index-list)
	  (let* ((v1 (controllers-state-value1 state))
		 (v2 (controllers-state-value2 state))
		 (saw (scanner state offset 0 (* 2 pi)))
		 (a (/ (- v2 v1) 2.0))
		 (b (+ v1 a))
		 (event-type (controllers-state-event-type state))
		 (blur (controllers-state-blur state))
		 (midi-events '()))
	    (dolist (p saw)
	      (let ((s (+ (* (cos (cdr p)) a) b)))
		(setf midi-events (append midi-events (create-point (car p) channel-index-list event-type s blur)))))
	  midi-events))

	 (create-sin2
	  (state offset channel-index-list)
	  (let* ((y1 (controllers-state-value1 state))
		 (y2 (controllers-state-value2 state))
		 (saw (scanner state offset 0 (* 2 pi)))
		 (a (/ (- y1 y2) 3.0))
		 (b (- y1 (* 3/2 a)))
		 (event-type (controllers-state-event-type state))
		 (blur (controllers-state-blur state))
		 (midi-events '()))
	    (dolist (p saw)
	      (let* ((x (cdr p))
		     (s1 (sin x))
		     (s2 (* 1/2 (sin (* 2 x))))
		     (s (+ b (* a (+ s1 s2))))
		     (pnt (create-point (car p) channel-index-list event-type s blur)))
		(setf midi-events (append midi-events pnt))))
	    midi-events))

	 (create-cos2
	  (state offset channel-index-list)
	  (let* ((y1 (controllers-state-value1 state))
		 (y2 (controllers-state-value2 state))
		 (saw (scanner state offset 0 (* 2 pi)))
		 (a (/ (- y1 y2) 3.0))
		 (b (- y1 (* 3/2 a)))
		 (event-type (controllers-state-event-type state))
		 (blur (controllers-state-blur state))
		 (midi-events '()))
	    (dolist (p saw)
	      (let* ((x (cdr p))
		     (s1 (cos x))
		     (s2 (* 1/2 (cos (* 2 x))))
		     (s (+ b (* a (+ s1 s2))))
		     (pnt (create-point (car p) channel-index-list event-type s blur)))
		(setf midi-events (append midi-events pnt))))
	    midi-events))

	 (create-lin+cos
	  (state offset channel-index-list)
	  (let* ((time1 (float (+ offset (controllers-state-time1 state))))
		 (time2 (+ offset (controllers-state-time2 state)))
		 (steps (controllers-state-steps state))
		 (time-increment (/ (abs (- time2 time1))(1- steps)))
		 (y1 (float (controllers-state-value1 state)))
		 (y2 (controllers-state-value2 state))
		 (y-increment (/ (- y2 y1)(1- steps)))
		 (cosx1 (* 2 pi (controllers-state-cycles state)))
		 (cosx-increment (/ cosx1 steps))
		 (cos-amp 1/16)
		 (cos-scale (/ cos-amp 2))
		 (cos-offset (- cos-amp cos-scale))
		 (event-type (controllers-state-event-type state))
		 (blur (controllers-state-blur state))
		 (time time1)
		 (y y1)
		 (cosx cosx1)
		 (midi-events '()))
	    (dotimes (i steps)
	      (let* ((c (+ (* cos-amp (cos cosx)) cos-offset))
		     (q (+ c y)))
		(setf midi-events (append midi-events (create-point time channel-index-list event-type q blur)))
		(setf time (+ time time-increment))
		(setf y (+ y y-increment))
		(setf cosx (+ cosx cosx-increment))))
	    midi-events)) )

  (defmethod render-once ((controllers controllers) &key (offset 0))
    (let* ((midi-events '())
	   (channel-index-list (let* ((instrument-pattern (property controllers :instruments))
				      (instrument-list (->list (next instrument-pattern :all))))
				 (mapcar #'channel-index instrument-list))))
      (dolist (state (controllers-events controllers))
	(let* ((time2 (+ offset (controllers-state-time2 state)))
	       (value1 (controllers-state-value1 state))
	       (curve (controllers-state-curve-type state))
	       (event-type (controllers-state-event-type state))
	       (blur (or (controllers-state-blur state) 0.0)))
	  (setf midi-events
		(cond ((eq curve 'point)
		       (append midi-events (create-point time2 channel-index-list event-type value1 blur)))
		      ((eq curve 'line)
		       (append midi-events (create-line state offset channel-index-list)))
		      ((eq curve 'saw)
		       (append midi-events (create-sawtooth state offset channel-index-list)))
		      ((eq curve 'tri)
		       (append midi-events (create-triangle state offset channel-index-list)))
		      ((eq curve 'random)
		       (append midi-events (create-random-values state offset channel-index-list)))
		      ((eq curve 'sin)
		       (append midi-events (create-sin1 state offset channel-index-list)))
		      ((eq curve 'cos)
		       (append midi-events (create-cos1 state offset channel-index-list)))
		      ((eq curve 'sin2)
		       (append midi-events (create-sin2 state offset channel-index-list)))
		      ((eq curve 'cos2)
		       (append midi-events (create-cos2 state offset channel-index-list)))
		      ((eq curve 'lin+cos)
		       (append midi-events (create-lin+cos state offset channel-index-list)))))))
      (dolist (child (reverse (children controllers)))
	(setf midi-events (append midi-events (render-once child :offset offset))))
      (sort-midi-events midi-events))) )

(defmethod render-n ((part controllers)(n integer) &key (offset 0.0))
  (let ((period (phrase-duration part))
	(template (render-once part))
	(midi-events '()))
    (dotimes (i (if (property part :render-once) 1 n))
      (dolist (evn template)
	(let ((reltime (car evn))
	      (msg (cdr evn)))
	  (push (cons (+ offset (* i period) reltime) msg) midi-events))))
    (sort-midi-events midi-events)))
