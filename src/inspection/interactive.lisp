;;;; CYCO inspection/interactive
;;;;

(in-package :cyco)

(defgeneric -? (object)
  (:documentation "Interactive object inspection.
Do not use -? directly.  Use ? method instead."))

(let ((exit-option 'x)
      (return-option '<)
      (stack '())
      (exit-flag nil)
      (page-size 10))

  (defun ? (object)
    "Interactive object inspection."
    (setf exit-flag nil)
    (-? object))
  
  (labels ((clear-stack () (setf stack '()))

	   (id (object)
	       (format nil "CLASS: ~A   NAME: ~A" (type-of object)(name object)))
	   
	   (bar (&optional object)
		(format t "---------------------- ~A~%"
			(if object (id object) "")))

	   (prompt ()
		   (format t "~D?: " (length stack))
		   (finish-output nil))

	   (wait ()
		 (format t "Options:~%")
		 (format t "  [~A] - Return to previous object~%" return-option)
		 (format t "  [~A] - Exit~%" exit-option)
		 (prompt)
		 (setf exit-flag (eq (read) exit-option)))
	   
	   (simple-menu (&key show-header)
			(if show-header (format t "Options:~%"))
			(format t "  [R] - Reset object~%")
			(format t "  [I] - Use inspect~%")
			(format t "  [~A] - Return to previous object~%" return-option)
			(format t "  [~A] - Exit~%" exit-option))
			    
	   (complex-menu (max-index)
			 (format t "Options:~%")
			 (format t "  Integer index 0 .. ~D to inspect element~%" max-index)
			 (format t "  [S] - Start~%")
			 (format t "  [E] - End~%")
			 (format t "  [P] - Previous page~%")
			 (format t "  [N] - Next page~%")
			 (simple-menu :show-header nil))
	   
	   (navigate (option start max)
		     (let (end)
		       (cond ((eq option 's)
			      (setf start 0))
			     ((eq option 'e)
			      (setf start (- max page-size)))
			     ((eq option 'p)
			      (setf start (- start page-size)))
			     ((eq option 'n)
			      (setf start (+ start page-size)))
			     (t nil))
		       (setf start (limit start 0 (1- max)))
		       (setf end (limit (+ start page-size) 0 max))
		       (values start end))) )
	  
	  (defmethod -? ((object t))
	    (if (not exit-flag)
		(progn 
		  (bar object)
		  ;; (format t "~A -> ~A~%" (type-of object) object)
		  (simple-menu :show-header t)
		  (let ((options (list exit-option return-option))
			(user nil))
		    (while (not (or (member user options) exit-flag))
		      (prompt)
		      (setf user (read))
		      (cond ((eq user 'i)
			     (inspect object))
			    ((eq user exit-option)
			     (clear-stack)
			     (setf exit-flag t))
			    ((eq user 'r)
			     (reset object))
			    ((and (eq user return-option) stack)
			     (-? (pop stack)))
			    (t nil)))))))

	  (defmethod -? ((object string))
	    (if (not exit-flag)
		(progn 
		  (bar object)
		  (format t "String -> ~S~%"  object)
		  (simple-menu :show-header t)
		  (let ((options (list exit-option return-option))
			(user nil))
		    (while (not (or (member user options) exit-flag))
		      (prompt)
		      (setf user (read))
		      (cond ((eq user 'i)
			     (inspect object))
			    ((eq user exit-option)
			     (clear-stack)
			     (setf exit-flag t))
			    ((and (eq user return-option) stack)
			     (-? (pop stack)))
			    (t nil)))))))
	  
	  (defmethod -? ((v vector))
	    (if (not exit-flag)
	  	(let* ((continue t)
	  	       (user nil)
	  	       (start 0)
	  	       (end (min (+ start page-size)(length v))))
	  	  (while (and continue (not exit-flag))
	  	    (bar v)
	  	    (format t "VECTOR or LIST  length ~D~%" (length v))
	  	    (loop for i from start below end do
	  		  (format t "[~4D] ~A~%" i (aref v i)))
	  	    (complex-menu (length v))
	  	    (prompt)
	  	    (setf user (read))
	  	    (multiple-value-bind (s e)
	  				 (navigate user start (length v)) 
	  				 (setf start s
	  				       end e))
		    (cond ((eq user 'i)
			   (inspect v))
			  ((and (integerp user)(>= user 0)(< user (length v)))
			    (push v stack)
			    (-? (aref v user)))
			   ((and (eq user return-option) stack)
			    (setf continue nil)
			    (-? (pop stack)))
			   ((eq user exit-option)
			    (clear-stack)
			    (setf exit-flag t))
			   (t nil))))))

	  
	  (defmethod -? ((lst list))
	    (-? (->vector lst)))

	  (defmethod -? ((tab hash-table))
	    (if (not exit-flag)
	  	(let* ((keys (let ((acc '()))
	  		       (maphash #'(lambda (k v)
	  				    (declare (ignore v))
	  				    (push k acc))
	  				tab)
	  		       (->vector (sort acc #'(lambda (a b)
	  					       (string< (name a)(name b)))))))
	  	       (start 0)
	  	       (end (min (+ start page-size)(length keys)))
	  	       (user nil)
	  	       (continue t))
	  	  (while (and continue (not exit-flag))
	  	    (bar tab)
	  	    (format t "~A~%" (type-of tab))
	  	    (loop for i from start below end do
	  		  (let* ((k (aref keys i))
	  			 (v (gethash k tab)))
	  		    (format t "[~4D] key ~20A -> ~A~%" i k v)))
	  	    (complex-menu (length keys))
	  	    (prompt)
	  	    (setf user (read))
		    (multiple-value-bind (s e)
	  				 (navigate user start (length keys)) 
	  				 (setf start s
	  				       end e))
		    (cond ((eq user 'i)
			   (inspect tab))
			  ((and (integerp user)(>= user 0)(< user (length keys)))
			   (push tab stack)
			   (let* ((key (aref keys user))
				  (value (gethash key tab)))
			     (-? value)))
			  ((and (eq user return-option) stack)
			   (setf continue nil)
			   (-? (pop stack)))
			  ((eq user exit-option)
			   (clear-stack)
			   (setf exit-flag t))
			  (t nil))))))

	  (defmethod -? ((node cyco-node))
	    (if (not exit-flag)
		(let* ((continue t)
		       (user nil)
		       (children (->vector (children node)))
		       (property-keys (->vector (property-keys node)))
		       (parent (parent node))
		       (is-instrument (typep node 'instrument)))
		      
		  (while (and continue (not exit-flag))
		    (bar node)
		    (format t "~A  NAME: ~A~%" (type-of node)(name node))
		    (format t "[   0] Parent   : ~A ~A~%" (type-of parent)(name parent))
		    (loop for i from 0 below (length children) do
			  (let ((child (aref children i)))
			    (format t "[~4D] Child    : ~12A ~A~%" (1+ i) (type-of child)(name child))))
		    (loop for i from 0 below (length property-keys) do
			  (let* ((key (aref property-keys i))
				 (value (property node key))
				 (j (1- (- i))))
			    (format t "[~4D] Property : ~16A -> ~A~%" j key value)))
		    (format t "OPTIONS:~%")
		    (format t "  0 for parent~%")
		    (format t "  Positive int for child     1 .. ~D~%" (length children))
		    (format t "  Negative int for property -1 .. ~D~%" (1- (- (length property-keys))))
		    (if is-instrument
			(progn
			  (format t "  [AM] - Articulation map docs~%")
			  (format t "  [DM] - Dynamic map docs~%")
			  (format t "  [KM] - Keynumber map docs~%")
			  (format t "  [PM] - Program map docs~%")))
		    (simple-menu :show-header nil)
		    (prompt)
		    (setf user (read))
		    (cond ((and (integerp user)(plusp user)(<= user (length children)))
			   (let ((child (aref children (1- user))))
			     (push node stack)
			     (-? child)))
			  ((and (integerp user)(minusp user))
			   (let* ((index (1- (abs user)))
				  (key (aref property-keys (min index (length property-keys))))
				  (value (property node key)))
			     (push node stack)
			     (-? value)))
			  ((and (integerp user)(zerop user))
			   (setf continue nil)
			   (push node stack)
			   (-? parent))
			  ((eq user 'i)
			   (inspect node))
			  ((eq user 'r)
			   (reset node))
			  ((and (eq user return-option) stack)
			   (setf continue nil)
			   (-? (pop stack)))
			  ((eq user exit-option)
			   (clear-stack)
			   (setf exit-flag t))
			  ((and is-instrument (eq user 'AM))
			   (bar)
			   (funcall (articulation-map node) :doc)
			   (wait))
			  ((and is-instrument (eq user 'dm))
			   (bar)
			   (funcall (dynamic-map node) :doc)
			   (wait))
			  ((and is-instrument (eq user 'km))
			   (bar)
			   (funcall (keynumber-map node) :doc)
			   (wait))
			  ((and is-instrument (eq user 'pm))
			   (bar)
			   (funcall (program-map node) 0 :program :doc)
			   (wait))
			  (t nil))))))
			   
			     
	  (defmethod -? ((pat pattern))
	    (if (not exit-flag)
		(let ((elements (elements pat))
		      (pointer (pointer pat))
		      (value (value pat))
		      (user nil)
		      (continue t))
		  (while (and continue (not exit-flag))
		    (bar pat)
		    (setf pointer (pointer pat))
		    (setf value (value pat))
		    (format t "~A~%" (type-of pat))
		    (format t "Elements : ~A~%" elements)
		    (format t "Pointer  : ~A~%" pointer)
		    (format t "Value    : ~A~%" value)

		    (format t "Options:~%")
		    (format t "  [E] - Elements~%")
		    (format t "  [V] - Value~%")
		    (format t "  [N] - Step pattern to next value~%")
		    (simple-menu :show-header nil)
		    (prompt)
		    (setf user (read))
		    (cond ((eq user 'i)
			   (inspect pat))
			  ((eq user 'r)
			   (reset pat))
			  ((eq user 'e)
			   (push pat stack)
			   (-? (elements pat)))
			  ((eq user 'v)
			   (push pat stack)
			   (-? (value pat)))
			  ((eq user 'n)
			   (next-1 pat))
			  ((eq user exit-option)
			   (clear-stack)
			   (setf exit-flag t))
			  ((and (eq user return-option) stack)
			   (-? (pop stack))))))))
			  
	  (defmethod -? ((gen generator))
	    (if (not exit-flag)
		(let ((user nil)
		      (continue t))
		  (while (and continue (not exit-flag))
		    (bar gen)
		    (format t "~A~%" (type-of gen))
		    (format t "Internal value : ~A~%" (internal-value gen))
		    (format t "Value          : ~A~%" (value gen))
		    (format t "Options:~%")
		    (format t "  [N] - Step generator to next value~%")
		    (simple-menu :show-header nil)
		    (prompt)
		    (setf user (read))
		      (cond ((eq user 'i)
			     (inspect gen))
			    ((eq user 'r)
			     (reset gen))
			    ((eq user 'n)
			     (next-1 gen))
			    ((eq user exit-option)
			     (clear-stack)
			     (setf exit-flag t))
			    ((and (eq user return-option) stack)
			     (-? (pop stack)))))))) ))
