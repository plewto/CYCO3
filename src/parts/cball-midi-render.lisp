(in-package :cyco-part)

(defmethod render-once ((cball cball) &key (offset 0.0))
  (if (muted-p cball)(return-from render-once nil))
  (if (property cball :reset-on-repeat)(reset cball))
  (let* ((midi-events '())
	 (cuefn (property cball :cue-function))
	 (current-time (funcall cuefn cball (property cball :start-cue)))
	 (end-time (funcall cuefn cball (property cball :end-cue)))
	 (time-increment (metric-expression (property cball :time-increment)))
	 (shift (property cball :shift))
	 (channel-index-list (mapcar #'channel-index (property cball :instruments)))
	 (pattern (property cball :value-pattern))
	 (controller (property cball :controller))
	 (data-map-function (cond ((integerp controller) #'norm->midi-data)
				  ((eq controller :pressure) #'norm->midi-data)
				  (t #'bend->midi-data)))
	 )
    (while (<= current-time end-time)
      (let* ((norm-value (next pattern))
	     (data (funcall data-map-function norm-value))
	     (time (+ current-time shift offset)))
	(dolist (ci channel-index-list)
	  (push (cons time (cond ((integerp controller)
				  (midi-control-change ci controller data))
				 ((eq controller :pressure)
				  (midi-channel-pressure ci data))
				 (t (let ((lsb (aref data 0))
					  (msb (aref data 1)))
				      (midi-pitch-bend ci lsb msb)))))
		midi-events))
	(setf current-time (+ current-time time-increment))))
    (sort-midi-events midi-events)))
    

(defmethod render-n ((cball cball)(n integer) &key (offset 0.0))
  (reset cball)
  (let ((period (phrase-duration cball))
	(midi-events '()))
    (dotimes (i (if (property cball :render-once) 1 n))
      (dolist (event (render-once cball))
	(let ((relative-time (car event))
	      (message (cdr event)))
	  (push (cons (+ offset (* i period) relative-time)(clone message))
		midi-events))))
    (sort-midi-events midi-events)))

	     
			    
